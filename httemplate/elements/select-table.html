<%doc>

Example:

  include( '/elements/select-table.html',

    #required
    'table'          => 'table_name',
    'name_col'       => 'name_column',
   
    #strongly recommended (you want your forms to be "sticky" on errors, right?)
    'curr_value'     => 'current_value',
    #'value' => #deprecated form of 'curr_value',
   
    #opt
    'empty_label'    => '', #better specify it though, the default might change
    'hashref'        => {},
    'extra_sql'      => '',
    'records'        => \@records, #instead of hashref
    'pre_options'    => [ 'value' => 'option' ], #before normal options
    'element_name'   => '', #HTML element name, defaults to the name of
                            # the primary key column
    'field'          => '', #synonym for element_name
    'element_etc'    => '', #additional attributes (i.e. "DISABLED") for the
                            #<SELECT> element
    'onchange'       => '', #javascript code
    'multiple'       => 0, # bool
    'disable_empty'  => 0, # bool (implied by multiple)
    'debug'          => 0, #set true to enable
    'label_callback' => sub { my $record = shift; return "label"; },
    'js_only'      => 0, #set true to return only the JS portions (i.e. nothing)
    'html_only'    => 0, #set true to return only the HTML portions (no-op, i.e. return everything)
  )

</%doc>
% unless ( $opt{'js_only'} ) {

<SELECT <% $opt{'multiple'} ? 'MULTIPLE' : '' %>
        NAME = "<% $opt{'element_name'} || $opt{'field'} || $key %>"
        ID   = "<% $opt{'id'} || $key %>"
        <% $onchange %>
        <% $opt{'element_etc'} %>
>

% while ( @pre_options ) { 
    <OPTION VALUE="<% shift(@pre_options) %>"><% shift(@pre_options) %>

% } 

% unless ( $opt{'multiple'} || $opt{'disable_empty'} ) {
    <OPTION VALUE=""><% $opt{'empty_label'} || 'all' %>
% }

% foreach my $record ( sort { $a->$name_col() cmp $b->$name_col() } @records ) {
%   my $recvalue = $record->$key();
    <OPTION VALUE="<% $recvalue %>"
            <% ref($value) && $value->{$recvalue} || $value == $recvalue
               ? ' SELECTED' : ''
            %>
    ><% $opt{'label_callback'}
          ? &{ $opt{'label_callback'} }( $record )
          : $record->$name_col()
     %>
% } 

</SELECT>

%}
<%init>

my( %opt ) = @_;

warn "elements/select-table.html: \n". Dumper(%opt)
  if exists $opt{debug} && $opt{debug};

my $onchange = '';
if ( $opt{'onchange'} ) {
  $onchange = $opt{'onchange'};
  $onchange .= '(this)' unless $onchange =~ /\(\w*\);?$/;
  $onchange =~ s/\(what\);/\(this\);/g; #ugh, terrible hack.  all onchange
                                        #callbacks should act the same
  $onchange = 'onChange="'. $onchange. '"';
}

my $dbdef_table = dbdef->table($opt{'table'})
  or die "can't find dbdef for ". $opt{'table'}. " table\n";

my $key = $dbdef_table->primary_key; #? $opt{'primary_key'} ||

my $name_col = $opt{'name_col'};

my $value = $opt{'curr_value'} || $opt{'value'};
$value = [ split(/\s*,\s*/, $value) ] if $opt{'multiple'} && $value =~ /,/;

my @records = ();
if ( $opt{'records'} ) {
  @records = @{ $opt{'records'} };
} else {
  @records = qsearch( {
    'table'     => $opt{'table'},
    'hashref'   => ( $opt{'hashref'} || {} ),
    'extra_sql' => ( $opt{'extra_sql'} || '' ),
    'order_by'  => ( $opt{'order_by'} || "ORDER BY $name_col" ),
  });
}

unless (    ! $value
         or ref($value)
         or ! exists( $opt{hashref}->{disabled} ) #??
         or grep { $value == $_->$key() } @records
       ) {
  delete $opt{hashref}->{disabled};
  $opt{hashref}->{$key} = $value;
  my $record = qsearchs( {
    'table'     => $opt{table},
    'hashref'   => $opt{hashref},
    'extra_sql' => ( $opt{extra_sql} || '' ),
  });
  push @records, $record if $record;
}

if ( ref( $value ) eq 'ARRAY' ) {
  $value = { map { $_ => 1 } @$value };
}

my @pre_options = $opt{pre_options} ? @{ $opt{pre_options} } : ();

</%init>
