<HTML>
<HEAD>
<TITLE>FS::Record - Database record objects</TITLE>
<LINK REV="made" HREF="mailto:perl@packages.debian.org">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#constructors">CONSTRUCTORS</A></LI>
	<LI><A HREF="#methods">METHODS</A></LI>
	<LI><A HREF="#subroutines">SUBROUTINES</A></LI>
	<LI><A HREF="#bugs">BUGS</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>FS::Record - Database record objects</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
    use FS::Record;
    use FS::Record qw(dbh fields qsearch qsearchs dbdef);</PRE>
<PRE>
    $record = new FS::Record 'table', \%hash;
    $record = new FS::Record 'table', { 'column' =&gt; 'value', ... };</PRE>
<PRE>
    $record  = qsearchs FS::Record 'table', \%hash;
    $record  = qsearchs FS::Record 'table', { 'column' =&gt; 'value', ... };
    @records = qsearch  FS::Record 'table', \%hash; 
    @records = qsearch  FS::Record 'table', { 'column' =&gt; 'value', ... };</PRE>
<PRE>
    $table = $record-&gt;table;
    $dbdef_table = $record-&gt;dbdef_table;</PRE>
<PRE>
    $value = $record-&gt;get('column');
    $value = $record-&gt;getfield('column');
    $value = $record-&gt;column;</PRE>
<PRE>
    $record-&gt;set( 'column' =&gt; 'value' );
    $record-&gt;setfield( 'column' =&gt; 'value' );
    $record-&gt;column('value');</PRE>
<PRE>
    %hash = $record-&gt;hash;</PRE>
<PRE>
    $hashref = $record-&gt;hashref;</PRE>
<PRE>
    $error = $record-&gt;insert;
    #$error = $record-&gt;add; #depriciated</PRE>
<PRE>
    $error = $record-&gt;delete;
    #$error = $record-&gt;del; #depriciated</PRE>
<PRE>
    $error = $new_record-&gt;replace($old_record);
    #$error = $new_record-&gt;rep($old_record); #depriciated</PRE>
<PRE>
    $value = $record-&gt;unique('column');</PRE>
<PRE>
    $error = $record-&gt;ut_float('column');
    $error = $record-&gt;ut_number('column');
    $error = $record-&gt;ut_numbern('column');
    $error = $record-&gt;ut_money('column');
    $error = $record-&gt;ut_text('column');
    $error = $record-&gt;ut_textn('column');
    $error = $record-&gt;ut_alpha('column');
    $error = $record-&gt;ut_alphan('column');
    $error = $record-&gt;ut_phonen('column');
    $error = $record-&gt;ut_anything('column');
    $error = $record-&gt;ut_name('column');</PRE>
<PRE>
    $dbdef = reload_dbdef;
    $dbdef = reload_dbdef &quot;/non/standard/filename&quot;;
    $dbdef = dbdef;</PRE>
<PRE>
    $quoted_value = _quote($value,'table','field');</PRE>
<PRE>
    #depriciated
    $fields = hfields('table');
    if ( $fields-&gt;{Field} ) { # etc.</PRE>
<PRE>
    @fields = fields 'table'; #as a subroutine
    @fields = $record-&gt;fields; #as a method call</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>(Mostly) object-oriented interface to database records.  Records are currently
implemented on top of DBI.  FS::Record is intended as a base class for
table-specific classes to inherit from, i.e. FS::cust_main.</P>
<P>
<HR>
<H1><A NAME="constructors">CONSTRUCTORS</A></H1>
<DL>
<DT><STRONG><A NAME="item_new_%5B_TABLE%2C_%5D_HASHREF">new [ TABLE, ] HASHREF</A></STRONG><BR>
<DD>
Creates a new record.  It doesn't store it in the database, though.  See
<A HREF="#insert">insert</A> for that.
<P>Note that the object stores this hash reference, not a distinct copy of the
hash it points to.  You can ask the object for a copy with the <EM>hash</EM> 
method.</P>
<P>TABLE can only be omitted when a dervived class overrides the table method.</P>
<P></P>
<DT><STRONG><A NAME="item_qsearch_TABLE%2C_HASHREF%2C_SELECT%2C_EXTRA_SQL">qsearch TABLE, HASHREF, SELECT, EXTRA_SQL</A></STRONG><BR>
<DD>
Searches the database for all records matching (at least) the key/value pairs
in HASHREF.  Returns all the records found as `FS::TABLE' objects if that
module is loaded (i.e. via `use FS::cust_main;'), otherwise returns FS::Record
objects.
<P>###oops, argh, FS::Record::new only lets us create database fields.
#Normal behaviour if SELECT is not specified is `*', as in
#<CODE>SELECT * FROM table WHERE ...</CODE>.  However, there is an experimental new
#feature where you can specify SELECT - remember, the objects returned,
#although blessed into the appropriate `FS::TABLE' package, will only have the
#fields you specify.  This might have unwanted results if you then go calling
#regular FS::TABLE methods
#on it.</P>
<P></P>
<DT><STRONG><A NAME="item_jsearch_TABLE%2C_HASHREF%2C_SELECT%2C_EXTRA_SQL%2C">jsearch TABLE, HASHREF, SELECT, EXTRA_SQL, PRIMARY_TABLE, PRIMARY_KEY</A></STRONG><BR>
<DD>
Experimental JOINed search method.  Using this method, you can execute a
single SELECT spanning multiple tables, and cache the results for subsequent
method calls.  Interface will almost definately change in an incompatible
fashion.
<P>Arguments:</P>
<P></P>
<DT><STRONG><A NAME="item_qsearchs">qsearchs TABLE, HASHREF</A></STRONG><BR>
<DD>
Same as qsearch, except that if more than one record matches, it <STRONG>carp</STRONG>s but
returns the first.  If this happens, you either made a logic error in asking
for a single item, or your data is corrupted.
<P></P></DL>
<P>
<HR>
<H1><A NAME="methods">METHODS</A></H1>
<DL>
<DT><STRONG><A NAME="item_table">table</A></STRONG><BR>
<DD>
Returns the table name.
<P></P>
<DT><STRONG><A NAME="item_dbdef_table">dbdef_table</A></STRONG><BR>
<DD>
Returns the FS::dbdef_table object for the table.
<P></P>
<DT><STRONG><A NAME="item_get%2C_getfield_COLUMN">get, getfield COLUMN</A></STRONG><BR>
<DD>
Returns the value of the column/field/key COLUMN.
<P></P>
<DT><STRONG><A NAME="item_set%2C_setfield_COLUMN%2C_VALUE">set, setfield COLUMN, VALUE</A></STRONG><BR>
<DD>
Sets the value of the column/field/key COLUMN to VALUE.  Returns VALUE.
<P></P>
<DT><STRONG><A NAME="item_AUTLOADED_METHODS">AUTLOADED METHODS</A></STRONG><BR>
<DD>
$record-&gt;column is a synonym for $record-&gt;get('column');
<P>$record-&gt;<CODE>column('value')</CODE> is a synonym for $record-&gt;set('column','value');</P>
<P></P>
<DT><STRONG><A NAME="item_hash">hash</A></STRONG><BR>
<DD>
Returns a list of the column/value pairs, usually for assigning to a new hash.
<P>To make a distinct duplicate of an FS::Record object, you can do:</P>
<PRE>
    $new = new FS::Record ( $old-&gt;table, { $old-&gt;hash } );</PRE>
<P></P>
<DT><STRONG><A NAME="item_hashref">hashref</A></STRONG><BR>
<DD>
Returns a reference to the column/value hash.
<P></P>
<DT><STRONG><A NAME="item_insert">insert</A></STRONG><BR>
<DD>
Inserts this record to the database.  If there is an error, returns the error,
otherwise returns false.
<P></P>
<DT><STRONG><A NAME="item_add">add</A></STRONG><BR>
<DD>
Depriciated (use insert instead).
<P></P>
<DT><STRONG><A NAME="item_delete">delete</A></STRONG><BR>
<DD>
Delete this record from the database.  If there is an error, returns the error,
otherwise returns false.
<P></P>
<DT><STRONG><A NAME="item_del">del</A></STRONG><BR>
<DD>
Depriciated (use delete instead).
<P></P>
<DT><STRONG><A NAME="item_replace_OLD_RECORD">replace OLD_RECORD</A></STRONG><BR>
<DD>
Replace the OLD_RECORD with this one in the database.  If there is an error,
returns the error, otherwise returns false.
<P></P>
<DT><STRONG><A NAME="item_rep">rep</A></STRONG><BR>
<DD>
Depriciated (use replace instead).
<P></P>
<DT><STRONG><A NAME="item_check">check</A></STRONG><BR>
<DD>
Not yet implemented, croaks.  Derived classes should provide a check method.
<P></P>
<DT><STRONG><A NAME="item_unique">unique COLUMN</A></STRONG><BR>
<DD>
Replaces COLUMN in record with a unique number.  Called by the <STRONG>add</STRONG> method
on primary keys and single-field unique columns (see <A HREF="../DBIx/DBSchema/Table.html">the DBIx::DBSchema::Table manpage</A>).
Returns the new value.
<P></P>
<DT><STRONG><A NAME="item_ut_float_COLUMN">ut_float COLUMN</A></STRONG><BR>
<DD>
Check/untaint floating point numeric data: 1.1, 1, 1.1e10, 1e10.  May not be
null.  If there is an error, returns the error, otherwise returns false.
<P></P>
<DT><STRONG><A NAME="item_ut_number_COLUMN">ut_number COLUMN</A></STRONG><BR>
<DD>
Check/untaint simple numeric data (whole numbers).  May not be null.  If there
is an error, returns the error, otherwise returns false.
<P></P>
<DT><STRONG><A NAME="item_ut_numbern_COLUMN">ut_numbern COLUMN</A></STRONG><BR>
<DD>
Check/untaint simple numeric data (whole numbers).  May be null.  If there is
an error, returns the error, otherwise returns false.
<P></P>
<DT><STRONG><A NAME="item_ut_money_COLUMN">ut_money COLUMN</A></STRONG><BR>
<DD>
Check/untaint monetary numbers.  May be negative.  Set to 0 if null.  If there
is an error, returns the error, otherwise returns false.
<P></P>
<DT><STRONG><A NAME="item_ut_text_COLUMN">ut_text COLUMN</A></STRONG><BR>
<DD>
Check/untaint text.  Alphanumerics, spaces, and the following punctuation
symbols are currently permitted: ! @ # $ % &amp; ( ) - + ; : ' `` , . ? /
May not be null.  If there is an error, returns the error, otherwise returns
false.
<P></P>
<DT><STRONG><A NAME="item_ut_textn_COLUMN">ut_textn COLUMN</A></STRONG><BR>
<DD>
Check/untaint text.  Alphanumerics, spaces, and the following punctuation
symbols are currently permitted: ! @ # $ % &amp; ( ) - + ; : ' `` , . ? /
May be null.  If there is an error, returns the error, otherwise returns false.
<P></P>
<DT><STRONG><A NAME="item_ut_alpha_COLUMN">ut_alpha COLUMN</A></STRONG><BR>
<DD>
Check/untaint alphanumeric strings (no spaces).  May not be null.  If there is
an error, returns the error, otherwise returns false.
<P></P>
<DT><STRONG>ut_alpha COLUMN</STRONG><BR>
<DD>
Check/untaint alphanumeric strings (no spaces).  May be null.  If there is an
error, returns the error, otherwise returns false.
<P></P>
<DT><STRONG><A NAME="item_ut_phonen_COLUMN_%5B_COUNTRY_%5D">ut_phonen COLUMN [ COUNTRY ]</A></STRONG><BR>
<DD>
Check/untaint phone numbers.  May be null.  If there is an error, returns
the error, otherwise returns false.
<P>Takes an optional two-letter ISO country code; without it or with unsupported
countries, ut_phonen simply calls ut_alphan.</P>
<P></P>
<DT><STRONG><A NAME="item_ut_ip_COLUMN">ut_ip COLUMN</A></STRONG><BR>
<DD>
Check/untaint ip addresses.  IPv4 only for now.
<P></P>
<DT><STRONG><A NAME="item_ut_ipn_COLUMN">ut_ipn COLUMN</A></STRONG><BR>
<DD>
Check/untaint ip addresses.  IPv4 only for now.  May be null.
<P></P>
<DT><STRONG><A NAME="item_ut_domain_COLUMN">ut_domain COLUMN</A></STRONG><BR>
<DD>
Check/untaint host and domain names.
<P></P>
<DT><STRONG><A NAME="item_ut_name_COLUMN">ut_name COLUMN</A></STRONG><BR>
<DD>
Check/untaint proper names; allows alphanumerics, spaces and the following
punctuation: , . - '
<P>May not be null.</P>
<P></P>
<DT><STRONG><A NAME="item_ut_zip_COLUMN">ut_zip COLUMN</A></STRONG><BR>
<DD>
Check/untaint zip codes.
<P></P>
<DT><STRONG><A NAME="item_ut_country_COLUMN">ut_country COLUMN</A></STRONG><BR>
<DD>
Check/untaint country codes.  Country names are changed to codes, if possible -
see <A HREF="../Locale/Country.html">the Locale::Country manpage</A>.
<P></P>
<DT><STRONG><A NAME="item_ut_anything_COLUMN">ut_anything COLUMN</A></STRONG><BR>
<DD>
Untaints arbitrary data.  Be careful.
<P></P>
<DT><STRONG><A NAME="item_ut_enum_COLUMN_CHOICES_ARRAYREF">ut_enum COLUMN CHOICES_ARRAYREF</A></STRONG><BR>
<DD>
Check/untaint a column, supplying all possible choices, like the ``enum'' type.
<P></P>
<DT><STRONG><A NAME="item_fields_%5B_TABLE_%5D">fields [ TABLE ]</A></STRONG><BR>
<DD>
This can be used as both a subroutine and a method call.  It returns a list
of the columns in this record's table, or an explicitly specified table.
(See <A HREF="../DBIx/DBSchema/Table.html">the DBIx::DBSchema::Table manpage</A>).
<P></P></DL>
<P>
<HR>
<H1><A NAME="subroutines">SUBROUTINES</A></H1>
<DL>
<DT><STRONG><A NAME="item_reload_dbdef"><CODE>reload_dbdef([FILENAME])</CODE></A></STRONG><BR>
<DD>
Load a database definition (see <A HREF="../DBIx/DBSchema.html">the DBIx::DBSchema manpage</A>), optionally from a
non-default filename.  This command is executed at startup unless
<EM>$FS::Record::setup_hack</EM> is true.  Returns a DBIx::DBSchema object.
<P></P>
<DT><STRONG><A NAME="item_dbdef">dbdef</A></STRONG><BR>
<DD>
Returns the current database definition.  See <A HREF="../FS/dbdef.html">the FS::dbdef manpage</A>.
<P></P>
<DT><STRONG><A NAME="item__quote_VALUE%2C_TABLE%2C_COLUMN">_quote VALUE, TABLE, COLUMN</A></STRONG><BR>
<DD>
This is an internal function used to construct SQL statements.  It returns
VALUE DBI-quoted (see <EM>DBI/``quote''</EM>) unless VALUE is a number and the column
type (see <A HREF="../FS/dbdef_column.html">the FS::dbdef_column manpage</A>) does not end in `char' or `binary'.
<P></P>
<DT><STRONG><A NAME="item_hfields">hfields TABLE</A></STRONG><BR>
<DD>
This is depriciated.  Don't use it.
<P>It returns a hash-type list with the fields of this record's table set true.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="bugs">BUGS</A></H1>
<P>This module should probably be renamed, since much of the functionality is
of general use.  It is not completely unlike Adapter::DBI (see below).</P>
<P>Exported qsearch and qsearchs should be depriciated in favor of method calls
(against an FS::Record object like the old search and searchs that qsearch
and qsearchs were on top of.)</P>
<P>The whole fields / hfields mess should be removed.</P>
<P>The various WHERE clauses should be subroutined.</P>
<P>table string should be depriciated in favor of FS::dbdef_table.</P>
<P>No doubt we could benefit from a Tied hash.  Documenting how exists / defined
true maps to the database (and WHERE clauses) would also help.</P>
<P>The ut_ methods should ask the dbdef for a default length.</P>
<P>ut_sqltype (like ut_varchar) should all be defined</P>
<P>A fallback check method should be provided which uses the dbdef.</P>
<P>The ut_money method assumes money has two decimal digits.</P>
<P>The Pg money kludge in the new method only strips `$'.</P>
<P>The ut_phonen method only checks US-style phone numbers.</P>
<P>The _quote function should probably use ut_float instead of a regex.</P>
<P>All the subroutines probably should be methods, here or elsewhere.</P>
<P>Probably should borrow/use some dbdef methods where appropriate (like sub
fields)</P>
<P>As of 1.14, DBI fetchall_hashref( {} ) doesn't set fetchrow_hashref NAME_lc,
or allow it to be set.  Working around it is ugly any way around - DBI should
be fixed.  (only affects RDBMS which return uppercase column names)</P>
<P>ut_zip should take an optional country like ut_phone.</P>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P><A HREF="../DBIx/DBSchema.html">the DBIx::DBSchema manpage</A>, <A HREF=".././FS/UID.html">the FS::UID manpage</A>, <EM>DBI</EM></P>
<P>Adapter::DBI from Ch. 11 of Advanced Perl Programming by Sriram Srinivasan.</P>

</BODY>

</HTML>
