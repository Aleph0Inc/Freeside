<HTML>
<HEAD>
<TITLE>FS::cust_pkg - Object methods for cust_pkg objects</TITLE>
<LINK REV="made" HREF="mailto:none">
</HEAD>

<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="#METHODS">METHODS</A>
	<LI><A HREF="#SUBROUTINES">SUBROUTINES</A>
	<LI><A HREF="#VERSION">VERSION</A>
	<LI><A HREF="#BUGS">BUGS</A>
	<LI><A HREF="#SEE_ALSO">SEE ALSO</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
FS::cust_pkg - Object methods for cust_pkg objects

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
<PRE>  use FS::cust_pkg;
</PRE>
<P>
<PRE>  $record = new FS::cust_pkg \%hash;
  $record = new FS::cust_pkg { 'column' =&gt; 'value' };
</PRE>
<P>
<PRE>  $error = $record-&gt;insert;
</PRE>
<P>
<PRE>  $error = $new_record-&gt;replace($old_record);
</PRE>
<P>
<PRE>  $error = $record-&gt;delete;
</PRE>
<P>
<PRE>  $error = $record-&gt;check;
</PRE>
<P>
<PRE>  $error = $record-&gt;cancel;
</PRE>
<P>
<PRE>  $error = $record-&gt;suspend;
</PRE>
<P>
<PRE>  $error = $record-&gt;unsuspend;
</PRE>
<P>
<PRE>  $part_pkg = $record-&gt;part_pkg;
</PRE>
<P>
<PRE>  @labels = $record-&gt;labels;
</PRE>
<P>
<PRE>  $error = FS::cust_pkg::order( $custnum, \@pkgparts );
  $error = FS::cust_pkg::order( $custnum, \@pkgparts, \@remove_pkgnums ] );
</PRE>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
An FS::cust_pkg object represents a customer billing item. FS::cust_pkg
inherits from FS::Record. The following fields are currently supported:

<DL>
<DT><STRONG><A NAME="item_pkgnum">pkgnum - primary key (assigned automatically for new billing items)</A></STRONG><DD>
<DT><STRONG><A NAME="item_custnum">custnum - Customer (see FS::cust_main)</A></STRONG><DD>
<DT><STRONG><A NAME="item_pkgpart">pkgpart - Billing item definition (see FS::part_pkg)</A></STRONG><DD>
<DT><STRONG><A NAME="item_setup">setup - date</A></STRONG><DD>
<DT><STRONG><A NAME="item_bill">bill - date</A></STRONG><DD>
<DT><STRONG><A NAME="item_susp">susp - date</A></STRONG><DD>
<DT><STRONG><A NAME="item_expire">expire - date</A></STRONG><DD>
<DT><STRONG><A NAME="item_cancel">cancel - date</A></STRONG><DD>
<DT><STRONG><A NAME="item_otaker">otaker - order taker (assigned automatically if null, see FS::UID)</A></STRONG><DD>
</DL>
<P>
Note: setup, bill, susp, expire and cancel are specified as UNIX
timestamps; see <EM>perlfunc</EM>. Also see <A HREF="../Time/Local.html">Time::Local</A> and <A HREF="../Date/Parse.html">Date::Parse</A> for conversion functions.

<P>
<HR>
<H1><A NAME="METHODS">METHODS</A></H1>
<DL>
<DT><STRONG><A NAME="item_new">new HASHREF</A></STRONG><DD>
<P>
Create a new billing item. To add the item to the database, see <A HREF="#insert">insert</A>.

<DT><STRONG><A NAME="item_insert">insert</A></STRONG><DD>
<P>
Adds this billing item to the database (``Orders'' the item). If there is
an error, returns the error, otherwise returns false.

<P>
sub insert { my <CODE>$self</CODE> = shift;

<P>
<PRE>  # custnum might not have have been defined in sub check (for one-shot new
  # customers), so check it here instead
</PRE>
<P>
<PRE>  my $error = $self-&gt;ut_number('custnum');
  return $error if $error
</PRE>
<P>
<PRE>  return &quot;Unknown customer&quot;
    unless qsearchs( 'cust_main', { 'custnum' =&gt; $self-&gt;custnum } );
</PRE>
<P>
<PRE>  $self-&gt;SUPER::insert;
</PRE>
<P>
}

<DT><STRONG><A NAME="item_delete">delete</A></STRONG><DD>
<P>
Currently unimplemented. You don't want to delete billing items, because
there would then be no record the customer ever purchased the item.
Instead, see the cancel method.

<DT><STRONG><A NAME="item_replace">replace OLD_RECORD</A></STRONG><DD>
<P>
Replaces the OLD_RECORD with this one in the database. If there is an
error, returns the error, otherwise returns false.

<P>
Currently, custnum, setup, bill, susp, expire, and cancel may be changed.

<P>
Changing pkgpart may have disasterous effects. See the order subroutine.

<P>
setup and bill are normally updated by calling the bill method of a
customer object (see <A HREF="../FS/cust_main.html">FS::cust_main</A>).

<P>
suspend is normally updated by the suspend and unsuspend methods.

<P>
cancel is normally updated by the cancel method (and also the order
subroutine in some cases).

<DT><STRONG><A NAME="item_check">check</A></STRONG><DD>
<P>
Checks all fields to make sure this is a valid billing item. If there is an
error, returns the error, otherwise returns false. Called by the insert and
replace methods.

<DT><STRONG>cancel</STRONG><DD>
<P>
Cancels and removes all services (see <A HREF="../FS/cust_svc.html">FS::cust_svc</A> and <A HREF="../FS/part_svc.html">FS::part_svc</A>) in this package, then cancels the package itself (sets the cancel field
to now).

<P>
If there is an error, returns the error, otherwise returns false.

<DT><STRONG><A NAME="item_suspend">suspend</A></STRONG><DD>
<P>
Suspends all services (see <A HREF="../FS/cust_svc.html">FS::cust_svc</A> and <A HREF="../FS/part_svc.html">FS::part_svc</A>) in this package, then suspends the package itself (sets the susp field to
now).

<P>
If there is an error, returns the error, otherwise returns false.

<DT><STRONG><A NAME="item_unsuspend">unsuspend</A></STRONG><DD>
<P>
Unsuspends all services (see <A HREF="../FS/cust_svc.html">FS::cust_svc</A> and <A HREF="../FS/part_svc.html">FS::part_svc</A>) in this package, then unsuspends the package itself (clears the susp
field).

<P>
If there is an error, returns the error, otherwise returns false.

<DT><STRONG><A NAME="item_part_pkg">part_pkg</A></STRONG><DD>
<P>
Returns the definition for this billing item, as an FS::part_pkg object
(see
<A HREF="../FS/part_pkg.html">FS::part_pkg</A>).

<DT><STRONG><A NAME="item_labels">labels</A></STRONG><DD>
<P>
Returns a list of lists, calling the label method for all services (see <A HREF="../FS/cust_svc.html">FS::cust_svc</A>) of this billing item.

</DL>
<P>
<HR>
<H1><A NAME="SUBROUTINES">SUBROUTINES</A></H1>
<DL>
<DT><STRONG><A NAME="item_order">order CUSTNUM, PKGPARTS_ARYREF, [ REMOVE_PKGNUMS_ARYREF ]</A></STRONG><DD>
<P>
CUSTNUM is a customer (see <A HREF="../FS/cust_main.html">FS::cust_main</A>)

<P>
PKGPARTS is a list of pkgparts specifying the the billing item definitions
(see
<A HREF="../FS/part_pkg.html">FS::part_pkg</A>) to order for this customer. Duplicates are of course permitted.

<P>
REMOVE_PKGNUMS is an optional list of pkgnums specifying the billing items
to remove for this customer. The services (see <A HREF="../FS/cust_svc.html">FS::cust_svc</A>) are moved to the new billing items. An error is returned if this is not
possible (see
<A HREF="../FS/pkg_svc.html">FS::pkg_svc</A>).

</DL>
<P>
<HR>
<H1><A NAME="VERSION">VERSION</A></H1>
<P>
$Id: cust_pkg.html,v 1.2 2000-03-03 18:22:43 ivan Exp $

<P>
<HR>
<H1><A NAME="BUGS">BUGS</A></H1>
<P>
sub order is not OO. Perhaps it should be moved to FS::cust_main and made
so?

<P>
In sub order, the <CODE>@pkgparts</CODE> array (passed by reference) is
clobbered.

<P>
Also in sub order, no money is adjusted. Once FS::part_pkg defines a
standard method to pass dates to the recur_prog expression, it should do
so.

<P>
FS::svc_acct, FS::svc_acct_sm, and FS::svc_domain are loaded via 'use' at
compile time, rather than via 'require' in sub { setup, suspend, unsuspend,
cancel } because they use %FS::UID::callback to load configuration values.
Probably need a subroutine which decides what to do based on whether or not
we've fetched the user yet, rather than a hash. See FS::UID and the TODO.

<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO</A></H1>
<P>
<A HREF="../FS/Record.html">FS::Record</A>, <A HREF="../FS/cust_main.html">FS::cust_main</A>, <A HREF="../FS/part_pkg.html">FS::part_pkg</A>, <A HREF="../FS/cust_svc.html">FS::cust_svc</A>
, <A HREF="../FS/pkg_svc.html">FS::pkg_svc</A>, schema.html from the base documentation

</BODY>

</HTML>
