#!/usr/bin/perl -w

use strict;
use vars qw( $log_file $sigterm $sigint $kids $max_kids );
use subs qw( _die _logmsg );
use Fcntl qw(:flock);
use POSIX qw(setsid);
use Date::Format;
use IO::File;
use FS::UID qw(adminsuidsetup forksuidsetup driver_name dbh);
use FS::Record qw(qsearchs);
use FS::queue;
use FS::queue_depend;

# no autoloading just yet
use FS::cust_main;
use FS::svc_acct;
use Net::SSH 0.06;
use FS::part_export;

$max_kids = '10'; #guess it should be a config file...
$kids = 0;

my $user = shift or die &usage;

#my $pid_file = "/var/run/freeside-queued.$user.pid";
my $pid_file = "/var/run/freeside-queued.pid";

&daemonize1;

sub REAPER { my $pid = wait; $SIG{CHLD} = \&REAPER; $kids--; }
$SIG{CHLD} =  \&REAPER;

$sigterm = 0;
$sigint = 0;
$SIG{INT} = sub { warn "SIGINT received; shutting down\n"; $sigint++; };
$SIG{TERM} = sub { warn "SIGTERM received; shutting down\n"; $sigterm++; };

$> = $FS::UID::freeside_uid unless $>;
$< = $>;
$ENV{HOME} = (getpwuid($>))[7]; #for ssh
adminsuidsetup $user;

$log_file = "/usr/local/etc/freeside/queuelog.". $FS::UID::datasrc;

&daemonize2;

$SIG{__DIE__} = \&_die;
$SIG{__WARN__} = \&_logmsg;

warn "freeside-queued starting\n";

my $warnkids=0;
while (1) {

  #prevent runaway forking
  if ( $kids >= $max_kids ) {
    warn "WARNING: maximum $kids children reached\n" unless $warnkids++;
    sleep 1; #waiting for signals is cheap
    next;
  }
  $warnkids=0;

  my $nodepend = driver_name eq 'mysql'
   ? ''
   : 'AND 0 = ( SELECT COUNT(*) FROM queue_depend'.
     ' WHERE queue_depend.jobnum = queue.jobnum ) ';

  #my($job, $ljob);
  #{
  #  my $oldAutoCommit = $FS::UID::AutoCommit;
  #  local $FS::UID::AutoCommit = 0;
  $FS::UID::AutoCommit = 0;
  my $dbh = dbh; 
  
  my $job = qsearchs(
    'queue',
    { 'status' => 'new' },
    '',
    driver_name eq 'mysql'
      ? "$nodepend ORDER BY jobnum LIMIT 1 FOR UPDATE"
      : "$nodepend ORDER BY jobnum FOR UPDATE LIMIT 1"
  ) or do {
    $dbh->commit or die $dbh->errstr; #if $oldAutoCommit;
    sleep 5; #connecting to db is expensive
    next;
  };

  if ( driver_name eq 'mysql'
       && qsearch('queue_depend', { 'jobnum' => $job->jobnum } ) ) {
    $dbh->commit or die $dbh->errstr; #if $oldAutoCommit;
    sleep 5; #would be better if mysql could do everything in query above
    next;
  }

  my %hash = $job->hash;
  $hash{'status'} = 'locked';
  my $ljob = new FS::queue ( \%hash );
  my $error = $ljob->replace($job);
  die $error if $error;

  $dbh->commit or die $dbh->errstr; #if $oldAutoCommit;

  $FS::UID::AutoCommit = 1;
  #} 

  my @args = $ljob->args;

  defined( my $pid = fork ) or do {
    warn "WARNING: can't fork: $!\n";
    my %hash = $job->hash;
    $hash{'status'} = 'failed';
    $hash{'statustext'} = "[freeside-queued] can't fork: $!";
    my $ljob = new FS::queue ( \%hash );
    my $error = $ljob->replace($job);
    die $error if $error;
    next; #don't increment the kid counter
  };

  if ( $pid ) {
    $kids++;
  } else { #kid time

    #get new db handle
    $FS::UID::dbh->{InactiveDestroy} = 1;

    forksuidsetup($user);

    #auto-use export classes...
    if ( $ljob->job =~ /(FS::part_export::\w+)::/ ) {
      my $class = $1;
      eval "use $class;";
      if ( $@ ) {
        warn "job use $class failed";
        my %hash = $ljob->hash;
        $hash{'status'} = 'failed';
        $hash{'statustext'} = $@;
        my $fjob = new FS::queue( \%hash );
        my $error = $fjob->replace($ljob);
        die $error if $error;
        exit; #end-of-kid
      };
    }

    my $eval = "&". $ljob->job. '(@args);';
    warn "running $eval";
    eval $eval; #throw away return value?  suppose so
    if ( $@ ) {
      warn "job $eval failed";
      my %hash = $ljob->hash;
      $hash{'status'} = 'failed';
      $hash{'statustext'} = $@;
      my $fjob = new FS::queue( \%hash );
      my $error = $fjob->replace($ljob);
      die $error if $error;
    } else {
      $ljob->delete;
    }

    exit;
    #end-of-kid
  }

} continue {
  if ( $sigterm ) {
    warn "received TERM signal; exiting\n";
    exit;
  }
  if ( $sigint ) {
    warn "received INT signal; exiting\n";
    exit;
  }
}

sub usage {
  die "Usage:\n\n  freeside-queued user\n";
}

sub _die {
  my $msg = shift;
  unlink $pid_file if -e $pid_file;
  _logmsg($msg);
}

sub _logmsg {
  chomp( my $msg = shift );
  my $log = new IO::File ">>$log_file";
  flock($log, LOCK_EX);
  seek($log, 0, 2);
  print $log "[". time2str("%a %b %e %T %Y",time). "] [$$] $msg\n";
  flock($log, LOCK_UN);
  close $log;
}

sub daemonize1 {

  chdir "/" or die "Can't chdir to /: $!";
  open STDIN, '/dev/null'   or die "Can't read /dev/null: $!";
  defined(my $pid = fork) or die "Can't fork: $!";
  if ( $pid ) {
    print "freeside-queued started with pid $pid\n"; #logging to $log_file\n";
    exit unless $pid_file;
    my $pidfh = new IO::File ">$pid_file" or exit;
    print $pidfh "$pid\n";
    exit;
  }
  #open STDOUT, '>/dev/null'
  #                          or die "Can't write to /dev/null: $!";
  #setsid                  or die "Can't start a new session: $!";
  #open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";

}

sub daemonize2 {
  open STDOUT, '>/dev/null'
                            or die "Can't write to /dev/null: $!";
  setsid                  or die "Can't start a new session: $!";
  open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";
}

=head1 NAME

freeside-queued - Job queue daemon

=head1 SYNOPSIS

  freeside-queued user

=head1 DESCRIPTION

Job queue daemon.  Should be running at all times.

user: from the mapsecrets file - see config.html from the base documentation

=head1 VERSION

=head1 BUGS

=head1 SEE ALSO

=cut

