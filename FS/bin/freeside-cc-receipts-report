#!/usr/bin/perl -Tw

use strict;
use Date::Parse;
use Time::Local;
use Getopt::Std;
use FS::Conf;
use FS::UID qw(adminsuidsetup);
use FS::Record qw(qsearch qsearchs);
use FS::cust_pay;
use FS::cust_pay_batch;

# Set the mail program
my $mail_program = "/usr/sbin/sendmail -t -n"; 

&untaint_argv;	#what it sounds like  (eww)
use vars qw($opt_v $opt_p $opt_e $opt_d $opt_s);
getopts("vped:s:");	#switches

#we're at now now (and later).
my($_enddate)= $main::opt_d ? str2time($main::opt_d) : $^T;
my($_startdate)= $main::opt_d ? str2time($main::opt_s) : $^T;

# Get the current month
my ($ssec,$smin,$shour,$smday,$smon,$syear) =
	(localtime($_startdate) )[0,1,2,3,4,5]; 
$syear+=1900;
$smon++;

# Get the current month
my ($esec,$emin,$ehour,$emday,$emon,$eyear) =
	(localtime($_enddate) )[0,1,2,3,4,5]; 
$eyear+=1900;
$emon++;

# Login to the database
my $user = shift or die &usage;
adminsuidsetup $user;

# Get the needed configuration files
my $conf = new FS::Conf;
my $lpr = $conf->config('lpr');
my $email = $conf->config('email');

my(@cust_pays)=qsearch('cust_pay',{});
if (scalar(@cust_pays) == 0)
{
	exit 1;
}

# Open print and email pipes
# $lpr and opt_p for printing
# $email and opt_e for email

if ($lpr && $main::opt_p)
{
        open(LPR, "|$lpr");
        print LPR qq~ C R E D I T  C A R D  R E C E I P T S  for period beginning: $smon/$smday/$syear and ending $emon/$emday/$eyear\n\n~;
}

if ($email && $main::opt_e)
{
	open (MAIL, "|$mail_program");
	print MAIL <<END
To: $email
From: Account Processor
Subject: Receivables


C R E D I T  C A R D  R E C E I P T S  for period beginning: $smon/$smday/$syear and ending $emon/$emday/$eyear

END
}

my $uninvoiced = 0;
my $total = 0;
my $taxed = 0;
my $untaxed = 0;
my $total_tax = 0;

# Now I can start looping
foreach my $cust_pay (@cust_pays)
{
	my $_date = $cust_pay->getfield('_date');
	my $invnum = $cust_pay->getfield('invnum');
	my $paid = $cust_pay->getfield('paid');
	my $payby = $cust_pay->getfield('payby');
	

	if ($_date >= $_startdate && $_date <= $_enddate && $payby =~ 'CARD') {
		$total += $paid;

		$uninvoiced += $cust_pay->unapplied; 
		my @cust_bill_pays = $cust_pay->cust_bill_pay;
                foreach my $cust_bill_pay (@cust_bill_pays) {
			my $invoice_amt =0;
			my $invoice_tax =0;
			my(@cust_bill_pkgs)= $cust_bill_pay->cust_bill->cust_bill_pkg;
			foreach my $cust_bill_pkg (@cust_bill_pkgs) {

				my $recur = $cust_bill_pkg->getfield('recur');
				my $setup = $cust_bill_pkg->getfield('setup');
				my $pkgnum = $cust_bill_pkg->getfield('pkgnum');
			
				if ($pkgnum == 0) {
					$invoice_tax += $recur;
					$invoice_tax += $setup;
				} else {
					$invoice_amt += $recur;
					$invoice_amt += $setup;
				}

			}

			if ($invoice_tax > 0) {
				if ($invoice_amt != $paid) {
					# attempt to prorate partially paid invoices
					$total_tax += $paid / ($invoice_amt + $invoice_tax) * $invoice_tax;
					$taxed += $paid / ($invoice_amt + $invoice_tax) * $invoice_amt;
				} else {
					$total_tax += $invoice_tax;
					$taxed += $invoice_amt;
				}
			} else {
				$untaxed += $paid;
			}

		}

	}

}

if ($main::opt_v) {
	printf(qq{\n%25s%14.2f\n}, "Uninvoiced", $uninvoiced);
	printf(qq{%25s%14.2f\n}, "Untaxed", $untaxed);
	printf(qq{%25s%14.2f\n}, "Taxed", $taxed);
	printf(qq{%25s%14.2f\n}, "Tax", $total_tax);
	printf(qq{\n%39s\n%39.2f\n}, "=========", $total);
}

# Now I need to close LPR and EMAIL if they were open
if($lpr && $main::opt_p)
{
	printf(LPR qq{\n%25s%14.2f\n}, "Uninvoiced", $uninvoiced);
	printf(LPR qq{%25s%14.2f\n}, "Untaxed", $untaxed);
	printf(LPR qq{%25s%14.2f\n}, "Taxed", $taxed);
	printf(LPR qq{%25s%14.2f\n}, "Tax", $total_tax);
	printf(LPR qq{\n%39s\n%39.2f\n}, "=========", $total);
	close LPR || die "Could not close printer: $lpr\n";
}
if($email && $main::opt_e)
{
	printf(MAIL qq{\n%25s%14.2f\n}, "Untaxed", $untaxed);
	printf(MAIL qq{%25s%14.2f\n}, "Taxed", $taxed);
	printf(MAIL qq{%25s%14.2f\n}, "Tax", $total_tax);
	printf(MAIL qq{\n%39s\n%39.2f\n}, "=========", $total);
	close MAIL || die "Could not close printer: $email\n";
}


# subroutines
sub untaint_argv {
  foreach $_ ( $[ .. $#ARGV ) { #untaint @ARGV
    $ARGV[$_] =~ /^([\w\-\/ :]*)$/ || die "Illegal argument \"$ARGV[$_]\"";
    $ARGV[$_]=$1;
  }
}

sub usage {
  die "Usage:\n\n  freeside-tax-report [-v] [-p] [-e] user\n";
}

=head1 NAME

freeside-tax-report - Prints or emails sales taxes invoiced in a given period.

=head1 SYNOPSIS

  freeside-tax-report [-v] [-p] [-e] user

=head1 DESCRIPTION

Prints or emails sales taxes invoiced in a given period.

-v: Verbose - Prints records to STDOUT.

-p: Print to printer lpr as found in the conf directory.

-e: Email output to user found in the Conf email file.

user: From the mapsecrets file - see config.html from the base documentation

=head1 VERSION

$Id: freeside-cc-receipts-report,v 1.1 2002-02-22 23:18:32 jeff Exp $

=head1 BUGS

Yes..... Use at your own risk. No guarantees or warrantees of any
kind apply to this program. Parts of this program are hacked from
other GNU licensed software created mainly by Ivan Kohler.

This is released under the GNU Public License. See www.gnu.org
for more information regarding this license.

=head1 SEE ALSO

L<FS::cust_main>, config.html from the base documentation

=head1 HISTORY

griff@aver-computer.com July 99

$Log: freeside-cc-receipts-report,v $
Revision 1.1  2002-02-22 23:18:32  jeff
add some reporting features

Revision 1.2  2002/02/19 14:24:53  jeff
might be functional now

Revision 1.1  2000/09/20 19:25:19  jeff
local modifications

Revision 1.1  2000/05/13 21:57:56  ivan
add print_batch script from Joel Griffiths


=cut


