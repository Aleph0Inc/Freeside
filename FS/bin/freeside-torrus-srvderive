#!/usr/bin/perl -w

use strict;
use Date::Parse;
use Date::Format;
use FS::Daemon ':all'; #daemonize1 drop_root daemonize2 myexit logfile sig*
use FS::UID qw( adminsuidsetup dbh driver_name );
use FS::Record qw( qsearch str2time_sql str2time_sql_closing concat_sql );
use FS::torrus_srvderive;

our $DEBUG = 2;

my $user = shift or die &usage;
$FS::Daemon::PID_NEWSTYLE = 1;
daemonize1('torrus-srvderive');

drop_root();

adminsuidsetup($user);

logfile( "%%%FREESIDE_LOG%%%/torrus-srvderive-log.". $FS::UID::datasrc );

daemonize2();

our $conf = new FS::Conf;

die "not running: network_monitoring_system not Torrus_Internal\n"
  unless _shouldrun();

#--

my $str2time = str2time_sql();
my $c = str2time_sql_closing();

my $_date = concat_sql([ 'srvexport.srv_date', "' '", 'srvexport.srv_time' ]);
$_date = "CAST( $_date AS TIMESTAMP )" if driver_name =~ /^Pg/i;
$_date = str2time_sql. $_date.  str2time_sql_closing;

my $other_date = concat_sql([ 'other.srv_date', "' '", 'other.srv_time' ]);
$other_date = "CAST( $other_date AS TIMESTAMP )" if driver_name =~ /^Pg/i;
$other_date = str2time_sql. $other_date.  str2time_sql_closing;

my $in  = concat_sql([ '?', "'_IN'" ]);
my $out = concat_sql([ '?', "'_OUT'" ]);

my $sql = "
  SELECT DISTINCT srv_date, srv_time FROM srvexport
    WHERE NOT EXISTS (
                       SELECT 1 FROM srvexport AS other
                         WHERE other.serviceid IN ( $in, $out )
                           AND srvexport.srv_date = other.srv_date
                           AND ABS( $_date - $other_date ) <= 60
                     )
";

my $orderlimit = "
    ORDER BY srv_date, srv_time
    LIMIT 100
";


while (1) {

  my $found = 0;

  foreach my $torrus_srvderive ( qsearch('torrus_srvderive', {}) ) {

    my $serviceid = $torrus_srvderive->serviceid;

    my @serviceids = $torrus_srvderive->component_serviceids;

    my @in = ();
    for my $dir ('_IN', '_OUT') {
      push @in, map dbh->quote("$_$dir"), @serviceids;
    }
    my $in = join(',', @in);

    my $ssql = "
      $sql AND EXISTS (
                       SELECT 1 FROM srvexport AS other
                         WHERE other.serviceid IN ($in)
                           AND srvexport.srv_date = other.srv_date
                           AND ABS( $_date - $other_date ) <= 60
                     )
    ";

    $ssql .= " AND srv_date >= '". $torrus_srvderive->last_srv_date. "' "
      if $torrus_srvderive->last_srv_date;

    $ssql .= $orderlimit;

    warn "searching for times to add $serviceid\n" if $DEBUG;
    warn $ssql if $DEBUG > 2;
    my $sth = dbh->prepare($ssql) or die $DBI::errstr; #better recovery?
    $sth->execute($serviceid, $serviceid) or die $sth->errstr;

    my $prev = 0;
    while ( my $row = $sth->fetchrow_arrayref ) {
      last if sigterm() || sigint();

      my( $srv_date, $srv_time ) = @$row;
      my $cur = str2time( "$srv_date $srv_time" );
      next if $cur-$prev <= 60;
      last if time - $cur <= 300;

      warn "no $serviceid for $srv_date $srv_time; adding\n"
        if $DEBUG;
      $found++;

      for my $dir ('_IN', '_OUT') {

        my $sin = join(',', map dbh->quote("$_$dir"), @serviceids);

        my $sum = "
          SELECT COALESCE(SUM(value),0) FROM srvexport AS other
            WHERE other.serviceid IN ($sin)
              AND ABS( $cur - $other_date ) <= 60
        ";

        my $isql = "
          INSERT INTO srvexport ( srv_date, srv_time, serviceid, value, intvl )
            VALUES ( ?, ?, ?, ($sum), ? )
        ";
        my @param = ( time2str('%Y-%m-%d', $cur), #srv_date
                      time2str('%X', $cur),       #srv_time
                      "$serviceid$dir",
                      300, #intvl ... 
                    );
        warn $isql. ' with param '. join(',',@param). "\n"
          if $DEBUG > 2;

        my $isth = dbh->prepare($isql) or die $DBI::errstr; #better recovery?
        $isth->execute( @param )       or die $isth->errstr;
                        
      }

      if ( $srv_date ne $torrus_srvderive->last_srv_date ) {
        warn "updating last_srv_date of $serviceid to $srv_date\n" if $DEBUG;
        $torrus_srvderive->last_srv_date($srv_date);
        my $error = $torrus_srvderive->replace;
        die $error if $error;
      }
      dbh->commit or die dbh->errstr;

      $prev = $cur;
    }
    warn "done with $serviceid\n" if $DEBUG;

  }

  myexit() if sigterm() || sigint();
  warn "restarting main loop\n" if $DEBUG > 1;
  sleep 60 unless $found;
}

sub _shouldrun {
     $conf->exists('network_monitoring_system')
  && $conf->config('network_monitoring_system') eq 'Torrus_Internal';
}

sub usage { 
  die "Usage:\n\n  freeside-cdrrewrited user\n";
}


=head1 NAME

freeside-torrus-srvderive - Freeside's Torrus virtual port daemon.

=head1 SYNOPSIS

  freeside-torrus-srvderive

=head1 DESCRIPTION

Runs continuously, searches for samples in the srvexport table which do not
have an entry for combined virtual ports, and adds them.

=head1 SEE ALSO

=cut

1;

