#!/usr/bin/perl -Tw

use strict;
#use Date::Format;
use Time::Local;
use Getopt::Std;
use FS::Conf;
use FS::UID qw(adminsuidsetup);
use FS::Record qw(qsearch);
use FS::cust_pay;
use FS::cust_pay_batch;

# Get the currennt time and date
my $time = time;
my ($sec,$min,$hour,$mday,$mon,$year) =
	(localtime($time) )[0,1,2,3,4,5]; 
my $_date =
	timelocal($sec,$min,$hour,$mday,$mon,$year);

# Set the mail program
my $mail_program = "/usr/sbin/sendmail -t -n"; 

&untaint_argv;	#what it sounds like  (eww)
use vars qw($opt_v $opt_p $opt_e $opt_a $opt_d);
getopts("vpead");	#switches

# Login to the database
my $user = shift or die &usage;
adminsuidsetup $user;

# Get the needed configuration files
my $conf = new FS::Conf;
my $lpr = $conf->config('lpr');
my $email = $conf->config('email');

my(@batch)=qsearch('cust_pay_batch',{});
if (scalar(@batch) == 0)
{
	exit 1;
}

# Open print and email pipes
# $lpr and opt_p for printing
# $email and opt_e for email
# 
if ($lpr && $main::opt_p)
{
	open(LPR, "|$lpr");
	print LPR qq~C R E D I T  C A R D  P A Y M E N T S  D U E $mon/$mday/$year\n\n~;
}

if ($email && $main::opt_e)
{
	open (MAIL, "|$mail_program");
	print MAIL <<END
To: $email
From: Account Processor
Subject: CREDIT CARD PAYMENTS DUE


C R E D I T  C A R D  P A Y M E N T S  D U E $mon/$mday/$year
END
}

# Now I can start looping
foreach my $cust_pay_batch (@batch)
{
	my $state = $cust_pay_batch->getfield('state');
	my $zip = $cust_pay_batch->getfield('zip');
	my $amount = $cust_pay_batch->getfield('amount');
	my $last = $cust_pay_batch->getfield('last');
	my $address1 = $cust_pay_batch->getfield('address1');
	my $address2 = $cust_pay_batch->getfield('address2');
	my $first = $cust_pay_batch->getfield('first');
	my $city = $cust_pay_batch->getfield('city');
	my $cardnum = $cust_pay_batch->getfield('cardnum');
	my $payname = $cust_pay_batch->getfield('payname');
	my $exp = $cust_pay_batch->getfield('exp');
	my $invnum = $cust_pay_batch->getfield('invnum');
	my $custnum = $cust_pay_batch->getfield('custnum');

	# Need a carriage return in address before address2
	# if it exists. Otherwise address will just be address1
	my $address = $address1;
	$address .= "\n$address2" if ($address2);

	# Only print to the screen in verbose mode
	if ($main::opt_v)
	{
		printf("Invoice %d for %s %s\tCustomer Number: %d\n",
			$invnum,
			$first,
			$last,
			$custnum);

		printf("\t%s\n", $address);
		printf("\t%s, %s, %s\n\n",
			$city,
			$state,
			$zip);

		printf("\tCard Number: %s\tExp:%s\n",
			$cardnum,
			$exp);
		printf("\t\tName: %s\n", $payname);
		printf("\t\tAmount: %.2f\n\n\n", $amount);
	}

	if ($lpr && $main::opt_p)
	{
		printf(LPR "Invoice %d for %s %s\tCustomer Number: %d\n",
			$invnum,
			$first,
			$last,
			$custnum);

		printf(LPR "\t%s\n", $address);
		printf(LPR "\t%s, %s, %s\n\n",
			$city,
			$state,
			$zip);

		printf(LPR "\tCard Number: %s\tExp:%s\n",
			$cardnum,
			$exp);
		printf(LPR "\t\tName: %s\n", $payname);
		printf(LPR "\t\tAmount: %.2f\n\n\n", $amount);
	}

	if ($email && $main::opt_e)
	{
		printf(MAIL "Invoice %d for %s %s\tCustomer Number: %d\n",
			$invnum,
			$first,
			$last,
			$custnum);

		printf(MAIL "\t%s\n", $address);
		printf(MAIL "\t%s, %s, %s\n\n",
			$city,
			$state,
			$zip);

		printf(MAIL "\tCard Number: %s\tExp:%s\n",
			$cardnum,
			$exp);
		printf(MAIL "\t\tName: %s\n", $payname);
		printf(MAIL "\t\tAmount: %.2f\n\n\n", $amount);
	}

	# Now I want to delete the records from cust_pay_batch
	# and mark the records in cust_pay as paid today if
	# the delete (-d) command line option is set.
	if($main::opt_a)
	{
		my $payment=new FS::cust_pay {
			'invnum' => $invnum,
			'paid' => $amount,
			'_date' => $_date,
			'payby' => "CARD",
			'payinfo' => $cardnum,
			'paybatch' => "AUTO",
		};
		
		my $pay_error=$payment->insert;
		if ($pay_error)
			{
				# warn might be better if you get root's mail
				# NEED TO TEST THIS BEFORE DELETE IF WARN IS USED
				die "Could not update cust_pay for invnum $invnum. $pay_error\n";
			}
	}
		
	# This just deletes the records
	# Must be last in the foreach loop
	if($main::opt_d)
	{
		my $del_error = $cust_pay_batch->delete;
		if ($del_error)
		{
			die "Could not delete cust_pay_batch for invnum $invnum. $del_error\n";
		}
	}

}

# Now I need to close LPR and EMAIL if they were open
if($lpr && $main::opt_p)
{
	close LPR || die "Could not close printer: $lpr\n";
}

if($email && $main::opt_e)
{
	close MAIL || die "Could not close printer: $lpr\n";
}


# subroutines
sub untaint_argv {
  foreach $_ ( $[ .. $#ARGV ) { #untaint @ARGV
    $ARGV[$_] =~ /^([\w\-\/]*)$/ || die "Illegal argument \"$ARGV[$_]\"";
    $ARGV[$_]=$1;
  }
}

sub usage {
  die "Usage:\n\n  freeside-print-batch [-v] [-p] [-e] [-a] [-d] user\n";
}

=head1 NAME

freeside-print-batch - Prints or emails cust_pay_batch. Also deletes
              old records and adds payment to cust_pay.
							Usually run after the bill command.

=head1 SYNOPSIS

  freeside-print-batch [-v] [-p] [-e] [-a] [-d] user

=head1 DESCRIPTION

Prints or emails cust_pay_batch. Can enter payment and delete
printed records. Usually run as a cron job.

B<-v>: Verbose - Prints records to STDOUT.

B<-p>: Print to printer lpr as found in the conf directory.

B<-e>: Email output to user found in the Conf email file.

B<-a>: Automatically pays all records in cust_pay_batch. Use -d with this option usually.

B<-d>:	Delete - Pays account and deletes record from cust_pay_batch.

user: From the mapsecrets file - see config.html from the base documentation

=head1 VERSION

$Id: freeside-print-batch,v 1.3 2001-08-21 02:44:47 ivan Exp $

=head1 BUGS

Yes..... Use at your own risk. No guarantees or warrantees of any
kind apply to this program. Parts of this program are hacked from
other GNU licensed software created mainly by Ivan Kohler.

This is released under the GNU Public License. See www.gnu.org
for more information regarding this license.

=head1 SEE ALSO

L<FS::cust_main>, config.html from the base documentation

=head1 AUTHOR

Joel Griffiths <griff@aver-computer.com> July 99

=cut

